<!DOCTYPE html>
<html lang="pt">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <title>Testes em Go</title>
    <meta name="author" content="An√≠bal Vilela">
    <meta name="description" content="Introdu√ß√£o a testes de unidade em Go usando as ferramentas nativas e a biblioteca gocheck.">

    <!--
        FIXME: add these to the other pages.

        https://stackoverflow.com/a/33545841

        https://stackoverflow.com/a/55959207
    -->
    <base target="_blank">
    <meta name="referrer" content="no-referrer">

    <link rel="stylesheet" href="/deps/highlight/style.min.css">
    <link rel="stylesheet" href="/css/main.css">

    <link rel="icon" type="image/x-icon" href="/resources/images/icons/favicon.ico">
</head>

<body>
    <html-include src="/common-html/nav-menu.html"></html-include>

    <main>
    <h1>Testes em Go</h1>

    <p>Aviso: esse post assume conhecimentos b√°sicos de <a href="https://golang.org/">Go</a> para focar apenas em bibliotecas de testes de unidade. Todo o c√≥digo fonte descrito pode ser baixado <a href="/resources/fossil/go-testing.fossil">aqui</a> na forma de um reposit√≥rio <a href="https://fossil-scm.org/home/doc/trunk/www/index.wiki">fossil</a>, onde cada t√≥pico possui uma branch dedicada; caso necess√°rio, o usu√°rio e a senha s√£o ambos <var>admin</var>.</p>

    <p>Primeiramente, vamos criar uma API; nada muito complicado, somente algumas rotas para termos o que testar:</p>

    <pre><code class="language-go">
    // main.go
    package main

    import (
        "fmt"
        "net/http"

        "github.com/gorilla/mux"
    )

    func main() {
        http.ListenAndServe(":8080", newRouter())
    }

    func newRouter() http.Handler {
        router := mux.NewRouter()
        router.
            HandleFunc("/", func(res http.ResponseWriter, _ *http.Request) {
                fmt.Fprintln(res, "hello")
            }).
            Methods(http.MethodGet)

        router.
            HandleFunc("/greet/{name}", func(response http.ResponseWriter, request *http.Request) {
                name := mux.Vars(request)["name"]
                fmt.Fprintf(response, "hallo, %s", name)
            }).
            Methods(http.MethodGet)

        return router
    }
    </code></pre>

    <p>(Estou me adiantando aqui e separando a defini√ß√£o das rotas em uma fun√ß√£o pr√≥pria. Isso ser√° relevante na hora de criar um servidor para testes.)</p>

    <p>Em Go, testes s√£o colocados em um arquivo com o sufixo <span class="file-name">*_test.go</span> ao lado do arquivo a ser testado na √°rvore de diret√≥rios. Os arquivos de testes podem ou n√£o pertencer ao mesmo pacote que o arquivo a ser testado, a diferen√ßa principal sendo o acesso a fun√ß√µes privadas &mdash; testes <em>whitebox</em> pertencem ao mesmo pacote, enquanto testes <em>blackbox</em> n√£o.</p>
    
    <pre><code class="language-go">
    // main_test.go
    package main

    import (
        "io/ioutil"
        "net/http"
        "net/http/httptest"
        "testing"
    )

    func TestGETRoot(t *testing.T) {
        server := httptest.NewServer(NewRouter())

        response, err := http.Get(server.URL + "/")
        if err != nil {
            t.Errorf("Unexpected error while getting %s: %s", server.URL, err)
        }
        defer response.Body.Close()

        responseText, err := ioutil.ReadAll(response.Body)
        if err != nil {
            t.Errorf("Unexpected error while reading response: %s", err)
        }

        if string(responseText) != "hello" {
            t.Errorf("Expected %s, but got %s", "hello", string(responseText))
        }
    }
    </code></pre>

    <p>Nativamente, a Go possui ferramentas para testes <a href="http://go.dev/doc/tutorial/add-a-test">de unidade</a>, <a href="https://pkg.go.dev/testing#hdr-Benchmarks"><em>benchmarks</em></a> e <a href="https://pkg.go.dev/testing#hdr-Examples">exemplos</a> (com <a href="https://go.dev/blog/fuzz-beta"><em>fuzzing</em></a> a caminho na vers√£o 1.18), e utiliz√°-las √© bem simples: basta escrever c√≥digo em Go com alguns pacotes auxiliares, como <a href="https://pkg.go.dev/net/http/httptest"><code>httptest</code></a> e <a href="https://pkg.go.dev/testing#T"><code>testing</code></a> &mdash; sobre esse √∫ltimo, √© importante notar que sua API possui fun√ß√µes para terminar a execu√ß√£o do teste atual (<a href="https://pkg.go.dev/testing#T.FailNow"><code>FailNow</code></a>, <a href="https://pkg.go.dev/testing#T.Fatal"><code>Fatal</code></a> e <a href="https://pkg.go.dev/testing#T.Fatalf"><code>Fatalf</code></a>) ou continuar apesar do erro (<a href="https://pkg.go.dev/testing#T.Fail"><code>Fail</code></a>, <a href="https://pkg.go.dev/testing#T.Error"><code>Error</code></a> e <a href="https://pkg.go.dev/testing#T.Errorf"><code>Errorf</code></a>).</p>

    <p>Essa simplicidade diminui o atrito para ler e entender o c√≥digo dos testes, por√©m ela tamb√©m traz suas surpresas; se voc√™ tentar rodar os testes como descritos acima, encontrar√° um erro inusitado:</p>

    <pre><code class="language-plaintext">
    ?       example.com/test        [no test files]
    ?       example.com/test/config [no test files]
    --- FAIL: TestGETRoot (0.00s)
        routes_test.go:27: Expected hello, but got hello
    OK: 1 passed
    FAIL
    FAIL    example.com/test/routes 0.564s
    FAIL
    </code></pre>

    <p>Ele espera <code>hello</code>, mas obteve <code>hello</code>? ü§∑‚Äç‚ôÇÔ∏è Esse resultado n√£o √© imediatamente √≥bvio (ao menos n√£o para mim), mas depois de algum tempo voc√™ pode resolver experimentar usar a especifica√ß√£o <a href="https://pkg.go.dev/fmt"><code>%#v</code></a> para formatar os resultados:</p>

    <pre><code class="language-go">
    t.Errorf("Expected %#v, but got %#v", "hello", string(responseText))
    </code></pre>

    <p>E ent√£o obt√©m-se um resultado mais esclarecedor:</p>

    <pre><code class="language-plaintext">
    ?       example.com/test        [no test files]
    ?       example.com/test/config [no test files]
    --- FAIL: TestGETRoot (0.00s)
        routes_test.go:27: Expected "hello", but got "hello\n"
    OK: 1 passed
    FAIL
    FAIL    example.com/test/routes 0.560s
    FAIL
    </code></pre>

    <p>Mas mesmo assim ainda temos de escrever manualmente as mensagens de erro &mdash; ou criar fun√ß√µes para automatizar isso. N√£o haveria uma forma mais conveniente?</p>

    <h2>Introduzindo <a href="http://github.com/go-check/check">gocheck</a></h2>

    <pre><code class="language-go">
    package main

    import (
        "io/ioutil"
        "net/http"
        "net/http/httptest"
        "testing"

        "gopkg.in/check.v1"
    )

    func Test(t *testing.T) { check.TestingT(t) }

    type RootPathTestSuite struct {
        server *httptest.Server
    }

    var _ = check.Suite(&RootPathTestSuite{})

    func (s *RootPathTestSuite) SetUpTest(c *check.C) {
        s.server = httptest.NewServer(newRouter())
    }

    func (s *RootPathTestSuite) TestGETRoot(c *check.C) {
        response, err := http.Get(s.server.URL + "/")
        c.Assert(err, check.IsNil)
        defer response.Body.Close()

        byteData, err := ioutil.ReadAll(response.Body)
        c.Assert(err, check.IsNil)

        data := string(byteData)
        c.Assert(data, check.Equals, "hello\n")
    }
    </code></pre>

    <p>Sua configura√ß√£o √© um pouco mais envolvida, ent√£o vamos em partes:</p>

    <pre><code class="language-go">
    func Test(t *testing.T) { check.TestingT(t) }
    </code></pre>

    </main>

    <!-- Leave these at the end -->
    <script src="/deps/highlight/highlight.min.js"></script>
    <script type="module" src="/js/main.js"></script>
</body>

</html>